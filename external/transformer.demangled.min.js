window["Transformer"] = function(modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
            return installedModules[moduleId].exports
        }
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.l = true;
        return module.exports
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
        if (!__webpack_require__.o(exports, name)) {
            Object.defineProperty(exports, name, {
                configurable: false,
                enumerable: true,
                get: getter
            })
        }
    };
    __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function getDefault() {
            return module["default"]
        } : function getModuleExports() {
            return module
        };
        __webpack_require__.d(getter, "a", getter);
        return getter
    };
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property)
    };
    __webpack_require__.p = "";
    return __webpack_require__(__webpack_require__.s = 9)
}([function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
        }
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor
    }
    var Matrix = function() {
        function Matrix(M) {
            _classCallCheck(this, Matrix);
            if (typeof M === "undefined" || !Array.isArray(M)) {
                throw new Error("first parameter needs to be a two-dimensional array")
            }
            this.matrix = M
        }
        _createClass(Matrix, [{
            key: "translate",
            value: function translate(tx, ty) {
                var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                var M = this.multiply(new Matrix([
                    [1, 0, tx],
                    [0, 1, ty],
                    [0, 0, 1]
                ]), truncate).matrix;
                this.matrix = M
            }
        }, {
            key: "rotate",
            value: function rotate(angle) {
                var truncate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                var rad = angle * (Math.PI / 180);
                var costheta = Math.cos(rad);
                var sintheta = Math.sin(rad);
                var M = this.multiply(new Matrix([
                    [costheta, -sintheta, 0],
                    [sintheta, costheta, 0],
                    [0, 0, 1]
                ]), truncate).matrix;
                this.matrix = M
            }
        }, {
            key: "scale",
            value: function scale(sx, sy) {
                var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                var M = this.multiply(new Matrix([
                    [sx, 0, 0],
                    [0, sy, 0],
                    [0, 0, 1]
                ]), truncate).matrix;
                this.matrix = M
            }
        }, {
            key: "skew",
            value: function skew(degX, degY) {
                var truncate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                var radX = degX * (Math.PI / 180);
                var radY = degY * (Math.PI / 180);
                var x = Math.tan(radX);
                var y = Math.tan(radY);
                var M = this.multiply(new Matrix([
                    [1, x, 0],
                    [y, 1, 0],
                    [0, 0, 1]
                ]), truncate).matrix;
                this.matrix = M
            }
        }, {
            key: "multiply",
            value: function multiply(M) {
                var truncate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                if (this.rows !== M.columns || this.columns !== M.rows) {
                    throw new Error("cannot multiply because matrix dimensions do not match (n*m !== m*n)")
                }
                var m = [];
                var m1 = this.matrix;
                var m2 = M.matrix;
                for (var i = 0; i < m1.length; i++) {
                    m[i] = [];
                    for (var j = 0; j < m2[0].length; j++) {
                        var sum = 0;
                        for (var k = 0; k < m1[0].length; k++) {
                            sum += m1[i][k] * m2[k][j]
                        }
                        m[i][j] = truncate ? parseFloat(sum.toFixed(3)) : sum
                    }
                }
                return new Matrix(m)
            }
        }, {
            key: "multiplyBy",
            value: function multiplyBy(M) {
                var m = M.multiply(this).matrix;
                this.matrix = m
            }
        }, {
            key: "copy",
            value: function copy() {
                var m = this.matrix;
                var copyM = JSON.parse(JSON.stringify(m));
                return new Matrix(copyM)
            }
        }, {
            key: "toJSON",
            value: function toJSON() {
                return JSON.stringify(this.matrix)
            }
        }, {
            key: "toCss",
            value: function toCss() {
                var fixed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                var M = this.matrix;
                var getFixedValue = function getFixedValue(row, column) {
                    if (fixed) {
                        return parseFloat(M[row][column].toFixed(3))
                    }
                    return M[row][column]
                };
                if (this.rows === 3 && this.columns === 3) {
                    if (this.equals(Matrix.identity(3))) {
                        return "none"
                    }
                    var a = getFixedValue(0, 0);
                    var b = getFixedValue(1, 0);
                    var c = getFixedValue(0, 1);
                    var d = getFixedValue(1, 1);
                    var tx = getFixedValue(0, 2);
                    var ty = getFixedValue(1, 2);
                    return "matrix(".concat(a, ", ").concat(b, ", ").concat(c, ", ").concat(d, ", ").concat(tx, ", ").concat(ty, ")")
                }
                if (this.equals(Matrix.identity(4))) {
                    return "none"
                }
                var a1 = getFixedValue(0, 0);
                var b1 = getFixedValue(1, 0);
                var c1 = getFixedValue(2, 0);
                var d1 = getFixedValue(3, 0);
                var a2 = getFixedValue(0, 1);
                var b2 = getFixedValue(1, 1);
                var c2 = getFixedValue(2, 1);
                var d2 = getFixedValue(3, 1);
                var a3 = getFixedValue(0, 2);
                var b3 = getFixedValue(1, 2);
                var c3 = getFixedValue(2, 2);
                var d3 = getFixedValue(3, 2);
                var a4 = getFixedValue(0, 3);
                var b4 = getFixedValue(1, 3);
                var c4 = getFixedValue(2, 3);
                var d4 = getFixedValue(3, 3);
                return "matrix3d(".concat(a1, ", ").concat(b1, ", ").concat(c1, ", ").concat(d1, ", ").concat(a2, ", ").concat(b2, ", ").concat(c2, ", ").concat(d2, ", ").concat(a3, ", ").concat(b3, ", ").concat(c3, ", ").concat(d3, ", ").concat(a4, ", ").concat(b4, ", ").concat(c4, ", ").concat(d4, ")")
            }
        }, {
            key: "equals",
            value: function equals(M) {
                return Matrix.equals(this, M)
            }
        }, {
            key: "toString",
            value: function toString() {
                return "Matrix [rows=".concat(this.rows, ",columns=").concat(this.columns, ",matrix=").concat(JSON.stringify(this.matrix), "]")
            }
        }, {
            key: "matrix",
            set: function set(matrix) {
                this._matrix = matrix;
                this._rows = matrix.length;
                this._columns = matrix[0].length
            },
            get: function get() {
                return this._matrix
            }
        }, {
            key: "rows",
            get: function get() {
                return this._rows
            }
        }, {
            key: "columns",
            get: function get() {
                return this._columns
            }
        }, {
            key: "a",
            get: function get() {
                return this.matrix[0][0]
            }
        }, {
            key: "b",
            get: function get() {
                return this.matrix[1][0]
            }
        }, {
            key: "c",
            get: function get() {
                return this.matrix[0][1]
            }
        }, {
            key: "d",
            get: function get() {
                return this.matrix[1][1]
            }
        }, {
            key: "tx",
            get: function get() {
                return this.matrix[0][2]
            }
        }, {
            key: "ty",
            get: function get() {
                return this.matrix[1][2]
            }
        }, {
            key: "angle",
            get: function get() {
                var rad = Math.atan2(this.b, this.a);
                return rad * 180 / Math.PI
            }
        }, {
            key: "scaleX",
            get: function get() {
                return this.a
            }
        }, {
            key: "scaleY",
            get: function get() {
                return this.d
            }
        }, {
            key: "inverse",
            get: function get() {
                var M = this.matrix;
                if (M.length !== M[0].length) {
                    throw new Error("matrix is not squared")
                }
                var i = 0,
                    ii = 0,
                    j = 0,
                    dim = M.length,
                    e = 0;
                var I = [],
                    C = [];
                for (i = 0; i < dim; i += 1) {
                    I[I.length] = [];
                    C[C.length] = [];
                    for (j = 0; j < dim; j += 1) {
                        if (i == j) {
                            I[i][j] = 1
                        } else {
                            I[i][j] = 0
                        }
                        C[i][j] = M[i][j]
                    }
                }
                for (i = 0; i < dim; i += 1) {
                    e = C[i][i];
                    if (e == 0) {
                        for (ii = i + 1; ii < dim; ii += 1) {
                            if (C[ii][i] != 0) {
                                for (j = 0; j < dim; j++) {
                                    e = C[i][j];
                                    C[i][j] = C[ii][j];
                                    C[ii][j] = e;
                                    e = I[i][j];
                                    I[i][j] = I[ii][j];
                                    I[ii][j] = e
                                }
                                break
                            }
                        }
                        e = C[i][i];
                        if (e == 0) {
                            throw new Error("matrix is not invertable")
                        }
                    }
                    for (j = 0; j < dim; j++) {
                        C[i][j] = C[i][j] / e;
                        I[i][j] = I[i][j] / e
                    }
                    for (ii = 0; ii < dim; ii++) {
                        if (ii == i) {
                            continue
                        }
                        e = C[ii][i];
                        for (j = 0; j < dim; j++) {
                            C[ii][j] -= e * C[i][j];
                            I[ii][j] -= e * I[i][j]
                        }
                    }
                }
                return new Matrix(I)
            }
        }], [{
            key: "fromJSON",
            value: function fromJSON(json) {
                var matrix = JSON.parse(json);
                return new Matrix(matrix)
            }
        }, {
            key: "equals",
            value: function equals(M1, M2) {
                return JSON.stringify(M1.matrix) === JSON.stringify(M2.matrix)
            }
        }, {
            key: "identity",
            value: function identity(n) {
                var m = [];
                for (var row = 0; row < n; row++) {
                    var mRow = m[row] = [];
                    for (var col = 0; col < n; col++) {
                        mRow[col] = col === row ? 1 : 0
                    }
                }
                return new Matrix(m)
            }
        }, {
            key: "from",
            value: function from(element) {
                var rawTransform = "none";
                if (element instanceof SVGElement) {
                    rawTransform = element.getAttribute("transform");
                    if (!rawTransform || rawTransform === "") {
                        rawTransform = element.style.transform
                    }
                } else if (element.nodeType === 1) {
                    rawTransform = window.getComputedStyle(element).transform
                }
                if (rawTransform === "" || rawTransform === "none") {
                    return Matrix.identity(3)
                } else {
                    var regEx = /([-+]?[\d\.]+)/g;
                    if (rawTransform.indexOf("matrix3d") > -1) {
                        var a1 = parseFloat(regEx.exec(rawTransform)[0]);
                        var b1 = parseFloat(regEx.exec(rawTransform)[0]);
                        var c1 = parseFloat(regEx.exec(rawTransform)[0]);
                        var d1 = parseFloat(regEx.exec(rawTransform)[0]);
                        var a2 = parseFloat(regEx.exec(rawTransform)[0]);
                        var b2 = parseFloat(regEx.exec(rawTransform)[0]);
                        var c2 = parseFloat(regEx.exec(rawTransform)[0]);
                        var d2 = parseFloat(regEx.exec(rawTransform)[0]);
                        var a3 = parseFloat(regEx.exec(rawTransform)[0]);
                        var b3 = parseFloat(regEx.exec(rawTransform)[0]);
                        var c3 = parseFloat(regEx.exec(rawTransform)[0]);
                        var d3 = parseFloat(regEx.exec(rawTransform)[0]);
                        var a4 = parseFloat(regEx.exec(rawTransform)[0]);
                        var b4 = parseFloat(regEx.exec(rawTransform)[0]);
                        var c4 = parseFloat(regEx.exec(rawTransform)[0]);
                        var d4 = parseFloat(regEx.exec(rawTransform)[0]);
                        return new Matrix([
                            [a1, a2, a3, a4],
                            [b1, b2, b3, b4],
                            [c1, c2, c3, c4],
                            [d1, d2, d3, d4]
                        ])
                    } else {
                        var a = parseFloat(regEx.exec(rawTransform)[0]);
                        var b = parseFloat(regEx.exec(rawTransform)[0]);
                        var c = parseFloat(regEx.exec(rawTransform)[0]);
                        var d = parseFloat(regEx.exec(rawTransform)[0]);
                        var tx = parseFloat(regEx.exec(rawTransform)[0]);
                        var ty = parseFloat(regEx.exec(rawTransform)[0]);
                        return new Matrix([
                            [a, c, tx],
                            [b, d, ty],
                            [0, 0, 1]
                        ])
                    }
                }
            }
        }]);
        return Matrix
    }();
    exports.default = Matrix
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
        }
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor
    }
    var Point = function() {
        function Point(x, y) {
            _classCallCheck(this, Point);
            this.x = x;
            this.y = y
        }
        _createClass(Point, [{
            key: "toString",
            value: function toString() {
                return "".concat(Point.name, " [x=").concat(this.x, ",y=").concat(this.y, "]")
            }
        }]);
        return Point
    }();
    exports.default = Point
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;
    var _point = _interopRequireDefault(__webpack_require__(1));
    var _matrix = _interopRequireDefault(__webpack_require__(0));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
        }
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor
    }
    var Transform = function() {
        function Transform() {
            _classCallCheck(this, Transform);
            this.matrix = _matrix.default.identity(3);
            this._centerPoint = new _point.default(0, 0)
        }
        _createClass(Transform, [{
            key: "apply",
            value: function apply(matrix) {
                var centerPointMatrix = _matrix.default.identity(3);
                centerPointMatrix.translate(this._centerPoint.x, this._centerPoint.y);
                matrix.multiplyBy(centerPointMatrix.inverse);
                matrix.multiplyBy(this.matrix);
                matrix.multiplyBy(centerPointMatrix)
            }
        }, {
            key: "unapply",
            value: function unapply(matrix) {
                var centerPointMatrix = _matrix.default.identity(3);
                centerPointMatrix.translate(this._centerPoint.x, this._centerPoint.y);
                matrix.multiplyBy(centerPointMatrix.inverse);
                matrix.multiplyBy(this.matrix.inverse);
                matrix.multiplyBy(centerPointMatrix)
            }
        }, {
            key: "reset",
            value: function reset() {
                this._centerPoint.x = 0;
                this._centerPoint.y = 0
            }
        }, {
            key: "centerPoint",
            get: function get() {
                return this._centerPoint
            }
        }, {
            key: "inverse",
            get: function get() {
                throw new Error("inverse not implemented for ".concat(this.constructor.name))
            }
        }], [{
            key: "from",
            value: function from(matrix) {
                throw new Error("inverse not implemented for transform")
            }
        }]);
        return Transform
    }();
    exports.default = Transform
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;
    var _matrix = _interopRequireDefault(__webpack_require__(0));
    var _transform = _interopRequireDefault(__webpack_require__(2));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }

    function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
                return typeof obj
            }
        } else {
            _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
            }
        }
        return _typeof(obj)
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
        }
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function")
        }
        _setPrototypeOf(subClass.prototype, superClass && superClass.prototype);
        if (superClass) _setPrototypeOf(subClass, superClass)
    }

    function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o
        };
        return _setPrototypeOf(o, p)
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor
    }

    function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call
        }
        return _assertThisInitialized(self)
    }

    function _assertThisInitialized(self) {
        if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
        }
        return self
    }

    function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
            _get = Reflect.get
        } else {
            _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);
                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);
                if (desc.get) {
                    return desc.get.call(receiver)
                }
                return desc.value
            }
        }
        return _get(target, property, receiver || target)
    }

    function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break
        }
        return object
    }

    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) {
            return o.__proto__
        };
        return _getPrototypeOf(o)
    }
    var TranslateTransform = function(_Transform) {
        function TranslateTransform() {
            var _this;
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck(this, TranslateTransform);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(TranslateTransform).call(this));
            _this.set(x, y);
            return _this
        }
        _createClass(TranslateTransform, [{
            key: "set",
            value: function set(x, y) {
                this.x = x;
                this.y = y;
                this.matrix = new _matrix.default([
                    [1, 0, x],
                    [0, 1, y],
                    [0, 0, 1]
                ])
            }
        }, {
            key: "update",
            value: function update(matrix) {
                if (!(matrix instanceof _matrix.default)) {
                    throw new Error("matrix needs to be of type ".concat(_matrix.default.name))
                }
                var M = matrix;
                var tx = M.tx;
                var ty = M.ty;
                this.set(tx, ty)
            }
        }, {
            key: "reset",
            value: function reset() {
                this.set(0, 0);
                _get(_getPrototypeOf(TranslateTransform.prototype), "reset", this).call(this)
            }
        }, {
            key: "toString",
            value: function toString() {
                return "".concat(this.constructor.name, " [x=").concat(this.x, ",y=").concat(this.y, "]")
            }
        }, {
            key: "inverse",
            get: function get() {
                return TranslateTransform.from(this.matrix.inverse)
            }
        }], [{
            key: "from",
            value: function from(matrix) {
                var transform = new TranslateTransform;
                transform.update(matrix);
                return transform
            }
        }]);
        _inherits(TranslateTransform, _Transform);
        return TranslateTransform
    }(_transform.default);
    exports.default = TranslateTransform
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;
    var _matrix = _interopRequireDefault(__webpack_require__(0));
    var _transform = _interopRequireDefault(__webpack_require__(2));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }

    function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
                return typeof obj
            }
        } else {
            _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
            }
        }
        return _typeof(obj)
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
        }
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function")
        }
        _setPrototypeOf(subClass.prototype, superClass && superClass.prototype);
        if (superClass) _setPrototypeOf(subClass, superClass)
    }

    function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o
        };
        return _setPrototypeOf(o, p)
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor
    }

    function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call
        }
        return _assertThisInitialized(self)
    }

    function _assertThisInitialized(self) {
        if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
        }
        return self
    }

    function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
            _get = Reflect.get
        } else {
            _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);
                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);
                if (desc.get) {
                    return desc.get.call(receiver)
                }
                return desc.value
            }
        }
        return _get(target, property, receiver || target)
    }

    function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break
        }
        return object
    }

    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) {
            return o.__proto__
        };
        return _getPrototypeOf(o)
    }
    var RotateTransform = function(_Transform) {
        function RotateTransform() {
            var _this;
            var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            _classCallCheck(this, RotateTransform);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(RotateTransform).call(this));
            _this.set(angle);
            return _this
        }
        _createClass(RotateTransform, [{
            key: "set",
            value: function set(angle) {
                this.angle = angle;
                var rad = angle * (Math.PI / 180);
                var costheta = Math.cos(rad);
                var sintheta = Math.sin(rad);
                this.matrix = new _matrix.default([
                    [costheta, -sintheta, 0],
                    [sintheta, costheta, 0],
                    [0, 0, 1]
                ])
            }
        }, {
            key: "update",
            value: function update(matrix) {
                if (!(matrix instanceof _matrix.default)) {
                    throw new Error("matrix needs to be of type ".concat(_matrix.default.name))
                }
                var M = matrix;
                var rad = Math.atan2(M.b, M.a);
                var angle = rad * 180 / Math.PI;
                this.set(angle)
            }
        }, {
            key: "reset",
            value: function reset() {
                this.set(0);
                _get(_getPrototypeOf(RotateTransform.prototype), "reset", this).call(this)
            }
        }, {
            key: "toString",
            value: function toString() {
                return "".concat(this.constructor.name, " [angle=").concat(this.angle, "]")
            }
        }, {
            key: "inverse",
            get: function get() {
                return RotateTransform.from(this.matrix.inverse)
            }
        }], [{
            key: "from",
            value: function from(matrix) {
                var transform = new RotateTransform;
                transform.update(matrix);
                return transform
            }
        }]);
        _inherits(RotateTransform, _Transform);
        return RotateTransform
    }(_transform.default);
    exports.default = RotateTransform
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;
    var _matrix = _interopRequireDefault(__webpack_require__(0));
    var _transform = _interopRequireDefault(__webpack_require__(2));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }

    function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
                return typeof obj
            }
        } else {
            _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
            }
        }
        return _typeof(obj)
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
        }
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function")
        }
        _setPrototypeOf(subClass.prototype, superClass && superClass.prototype);
        if (superClass) _setPrototypeOf(subClass, superClass)
    }

    function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o
        };
        return _setPrototypeOf(o, p)
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor
    }

    function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call
        }
        return _assertThisInitialized(self)
    }

    function _assertThisInitialized(self) {
        if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
        }
        return self
    }

    function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
            _get = Reflect.get
        } else {
            _get = function _get(target, property, receiver) {
                var base = _superPropBase(target, property);
                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);
                if (desc.get) {
                    return desc.get.call(receiver)
                }
                return desc.value
            }
        }
        return _get(target, property, receiver || target)
    }

    function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break
        }
        return object
    }

    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) {
            return o.__proto__
        };
        return _getPrototypeOf(o)
    }
    var ScaleTransform = function(_Transform) {
        function ScaleTransform() {
            var _this;
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            _classCallCheck(this, ScaleTransform);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(ScaleTransform).call(this));
            _this.set(x, y);
            return _this
        }
        _createClass(ScaleTransform, [{
            key: "set",
            value: function set(x, y) {
                this.x = x;
                this.y = y;
                this.matrix = new _matrix.default([
                    [x, 0, 0],
                    [0, y, 0],
                    [0, 0, 1]
                ])
            }
        }, {
            key: "update",
            value: function update(matrix) {
                if (!(matrix instanceof _matrix.default)) {
                    throw new Error("matrix needs to be of type ".concat(_matrix.default.name))
                }
                var M = matrix;
                var sx = Math.sqrt(Math.pow(M.a, 2) + Math.pow(M.b, 2));
                var sy = Math.sqrt(Math.pow(M.c, 2) + Math.pow(M.d, 2));
                this.set(sx, sy)
            }
        }, {
            key: "reset",
            value: function reset() {
                this.set(1, 1);
                _get(_getPrototypeOf(ScaleTransform.prototype), "reset", this).call(this)
            }
        }, {
            key: "toString",
            value: function toString() {
                return "".concat(this.constructor.name, " [x=").concat(this.x, ",y=").concat(this.y, "]")
            }
        }, {
            key: "inverse",
            get: function get() {
                return ScaleTransform.from(this.matrix.inverse)
            }
        }], [{
            key: "from",
            value: function from(matrix) {
                var transform = new ScaleTransform;
                transform.update(matrix);
                return transform
            }
        }]);
        _inherits(ScaleTransform, _Transform);
        return ScaleTransform
    }(_transform.default);
    exports.default = ScaleTransform
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;
    var _transform = _interopRequireDefault(__webpack_require__(2));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }

    function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
                return typeof obj
            }
        } else {
            _typeof = function _typeof(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
            }
        }
        return _typeof(obj)
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
        }
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function")
        }
        _setPrototypeOf(subClass.prototype, superClass && superClass.prototype);
        if (superClass) _setPrototypeOf(subClass, superClass)
    }

    function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o
        };
        return _setPrototypeOf(o, p)
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor
    }

    function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call
        }
        return _assertThisInitialized(self)
    }

    function _assertThisInitialized(self) {
        if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
        }
        return self
    }

    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) {
            return o.__proto__
        };
        return _getPrototypeOf(o)
    }
    var TransformGroup = function(_Transform) {
        function TransformGroup() {
            var _this;
            _classCallCheck(this, TransformGroup);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(TransformGroup).call(this));
            _this.transforms = [];
            return _this
        }
        _createClass(TransformGroup, [{
            key: "add",
            value: function add(transform) {
                var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                if (!(transform instanceof _transform.default)) {
                    throw new Error("transform needs to be of type ".concat(_transform.default.name))
                }
                this.transforms.push({
                    inverse: inverse,
                    transform: transform
                })
            }
        }, {
            key: "remove",
            value: function remove(transform) {
                if (!(transform instanceof _transform.default)) {
                    throw new Error("transform needs to be of type ".concat(_transform.default.name))
                }
                if (!this.transforms.contains(transform)) {
                    throw new Error("transform is not part of this transform group")
                }
                var idx = this.transforms.indexOf(transform);
                this.transforms.splice(idx, 1)
            }
        }, {
            key: "apply",
            value: function apply(matrix) {
                var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                this.transforms.forEach(function(_ref) {
                    var transform = _ref.transform,
                        inverse = _ref.inverse;
                    if (type && !(transform instanceof type) && !(transform instanceof TransformGroup)) {
                        return
                    }
                    inverse ? transform.unapply(matrix, type) : transform.apply(matrix, type)
                })
            }
        }, {
            key: "unapply",
            value: function unapply(matrix) {
                var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                this.transforms.slice().reverse().forEach(function(_ref2) {
                    var transform = _ref2.transform,
                        inverse = _ref2.inverse;
                    if (type && !(transform instanceof type) && !(transform instanceof TransformGroup)) {
                        return
                    }
                    inverse ? transform.apply(matrix, type) : transform.unapply(matrix, type)
                })
            }
        }, {
            key: "reset",
            value: function reset() {
                this.transforms.forEach(function(_ref3) {
                    var transform = _ref3.transform;
                    transform.reset()
                })
            }
        }, {
            key: "toString",
            value: function toString() {
                return "".concat(this.constructor.name, " [transforms=[").concat(this.transforms.map(function(_ref4) {
                    var transform = _ref4.transform,
                        inverse = _ref4.inverse;
                    return inverse ? transform.inverse.toString() : transform.toString()
                }).join(", "), "]]")
            }
        }]);
        _inherits(TransformGroup, _Transform);
        return TransformGroup
    }(_transform.default);
    exports.default = TransformGroup
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = void 0;
    var _point = _interopRequireDefault(__webpack_require__(1));
    var _matrix = _interopRequireDefault(__webpack_require__(0));
    var _translateTransform = _interopRequireDefault(__webpack_require__(3));
    var _rotateTransform = _interopRequireDefault(__webpack_require__(4));
    var _scaleTransform = _interopRequireDefault(__webpack_require__(5));
    var _transformGroup = _interopRequireDefault(__webpack_require__(6));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function")
        }
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor
    }
    var Transformer = function() {
        _createClass(Transformer, null, [{
            key: "version",
            get: function get() {
                return "{{PKG_VERSION}}"
            }
        }]);

        function Transformer(element, callback) {
            var debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            _classCallCheck(this, Transformer);
            if (!element.parentElement) {
                throw new Error("Element has no parent element. Is the element in the DOM?")
            }
            if (callback && typeof callback !== "function") {
                throw new Error("callback needs to be a function")
            }
            this.element = element;
            this.element.transformer = this;
            this.callback = callback;
            this.updateInProgress = false;
            var matrix = this.getTransformMatrix();
            this._scaleTransform = _scaleTransform.default.from(matrix);
            this._rotateTransform = _rotateTransform.default.from(matrix);
            this._translateTransform = _translateTransform.default.from(matrix);
            var transformGroup = new _transformGroup.default;
            transformGroup.add(this._rotateTransform);
            transformGroup.add(this._scaleTransform);
            transformGroup.add(this._translateTransform);
            this._transforms = transformGroup;
            if (debug) {
                var visualTransformOrigin = this.element.querySelector(":scope > .transform-origin-point");
                if (!visualTransformOrigin) {
                    visualTransformOrigin = document.createElement("transient");
                    visualTransformOrigin.setAttribute("class", "transform-origin-point");
                    element.insertBefore(visualTransformOrigin, element.firstElementChild)
                }
            }
        }
        _createClass(Transformer, [{
            key: "getTransformMatrix",
            value: function getTransformMatrix() {
                return _matrix.default.from(this.element)
            }
        }, {
            key: "refreshTransforms",
            value: function refreshTransforms() {
                var matrix = this.getTransformMatrix();
                this._translateTransform.update(matrix);
                this._rotateTransform.update(matrix);
                this._scaleTransform.update(matrix)
            }
        }, {
            key: "reapplyTransforms",
            value: function reapplyTransforms() {
                var updateElementsTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                var matrix = _matrix.default.identity(3);
                if (this.element.renderTransform) {
                    this.element.renderTransform.apply(matrix)
                }
                this._transforms.apply(matrix);
                this.elementMatrix = matrix;
                if (updateElementsTransform) {
                    return this.updateElement()
                } else {
                    return new Promise(function(resolve, reject) {
                        resolve()
                    })
                }
            }
        }, {
            key: "complete",
            value: function complete() {
                if (this.element.renderTransform) {
                    this.refreshTransforms();
                    this.element.renderTransform.reset()
                }
            }
        }, {
            key: "updateElement",
            value: function updateElement() {
                var _this = this;
                return new Promise(function(resolve, reject) {
                    if (_this.updateInProgress) {
                        return
                    }
                    window.requestAnimationFrame(function() {
                        var updateElementTransform = function updateElementTransform() {
                            var elementTransform = _this.elementMatrix.toCss();
                            _this.setCssTransform(elementTransform)
                        };
                        if (typeof _this.callback === "function") {
                            if (_this.callback.call(_this, _this.elementMatrix)) {
                                updateElementTransform()
                            }
                        } else {
                            updateElementTransform()
                        }
                        _this.updateInProgress = false;
                        resolve(_this.elementMatrix)
                    });
                    _this.updateInProgress = true
                })
            }
        }, {
            key: "setCssTransform",
            value: function setCssTransform(cssTransform) {
                this.element.style.position = "absolute";
                this.element.style.transformOrigin = "0 0 0";
                if (this.element instanceof SVGElement) {
                    cssTransform === "none" ? this.element.removeAttribute("transform") : this.element.setAttribute("transform", cssTransform)
                    this.element.style.webkitTransform = cssTransform;
                } else if (this.element.nodeType === 1) {
                    this.element.style.webkitTransform = cssTransform;
                    this.element.style.mozTransform = cssTransform;
                    this.element.style.msTransform = cssTransform;
                    this.element.style.oTransform = cssTransform;
                    this.element.style.transform = cssTransform
                }
            }
        }, {
            key: "getTransformHierarchy",
            value: function getTransformHierarchy() {
                var allTransformers = [];
                var parent = this.element;
                do {
                    if (parent.transformer) {
                        allTransformers.push({
                            transformer: parent.transformer,
                            renderTransform: parent.renderTransform
                        })
                    }
                } while ((parent = parent.parentElement) !== null);
                allTransformers.reverse();
                return allTransformers
            }
        }, {
            key: "getAncesterElementWithoutTransformer",
            value: function getAncesterElementWithoutTransformer() {
                var parent = this.element;
                do {
                    if (!parent.transformer) {
                        return parent
                    }
                } while ((parent = parent.parentElement) !== null);
                return window.document.body
            }
        }, {
            key: "applyToLocalTransform",
            value: function applyToLocalTransform(m) {
                var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                this._transforms.apply(m, type);
                if (this.element.renderTransform) {
                    this.element.renderTransform.apply(m, type)
                }
            }
        }, {
            key: "applyToGlobalTransform",
            value: function applyToGlobalTransform(m) {
                var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var allTransformers = this.getTransformHierarchy();
                allTransformers.forEach(function(_ref) {
                    var transformer = _ref.transformer,
                        renderTransform = _ref.renderTransform;
                    if (transformer) {
                        transformer._transforms.unapply(m, type)
                    }
                    if (renderTransform) {
                        renderTransform.unapply(m, type)
                    }
                })
            }
        }, {
            key: "unapplyFromGlobalTransform",
            value: function unapplyFromGlobalTransform(m) {
                var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                var allTransformers = this.getTransformHierarchy();
                allTransformers.forEach(function(_ref2) {
                    var transformer = _ref2.transformer,
                        renderTransform = _ref2.renderTransform;
                    if (renderTransform) {
                        renderTransform.apply(m, type)
                    }
                    if (transformer) {
                        transformer._transforms.apply(m, type)
                    }
                })
            }
        }, {
            key: "fromGlobalToLocal",
            value: function fromGlobalToLocal(point) {
                if (!(point instanceof _point.default)) {
                    throw new Error("point needs to be of instance ".concat(_point.default.name))
                }
                var ancestor = this.getAncesterElementWithoutTransformer();
                var _ancestor$getBounding = ancestor.getBoundingClientRect(),
                    left = _ancestor$getBounding.left,
                    top = _ancestor$getBounding.top;
                var x = left ? point.x - left : point.x;
                var y = top ? point.y - top : point.y;
                var m = _matrix.default.identity(3);
                m.translate(x, y);
                this.applyToGlobalTransform(m);
                return new _point.default(m.tx, m.ty)
            }
        }, {
            key: "fromLocalToGlobal",
            value: function fromLocalToGlobal(point) {
                if (!(point instanceof _point.default)) {
                    throw new Error("point needs to be of instance ".concat(_point.default.name))
                }
                var m = _matrix.default.identity(3);
                m.translate(point.x, point.y);
                this.unapplyFromGlobalTransform(m);
                var ancestor = this.getAncesterElementWithoutTransformer();
                var _ancestor$getBounding2 = ancestor.getBoundingClientRect(),
                    left = _ancestor$getBounding2.left,
                    top = _ancestor$getBounding2.top;
                var x = left ? m.tx + left : m.tx;
                var y = top ? m.ty + top : m.ty;
                return new _point.default(x, y)
            }
        }, {
            key: "fromGlobalToLocalDelta",
            value: function fromGlobalToLocalDelta(deltaPoint) {
                if (!(deltaPoint instanceof _point.default)) {
                    throw new Error("delta point needs to be of instance ".concat(_point.default.name))
                }
                var allTransforms = this.getTransformHierarchy();
                var m = _matrix.default.identity(3);
                m.translate(deltaPoint.x, deltaPoint.y);
                allTransforms.forEach(function(_ref3) {
                    var transformer = _ref3.transformer,
                        renderTransform = _ref3.renderTransform;
                    if (transformer) {
                        transformer._transforms.unapply(m, _scaleTransform.default);
                        transformer._transforms.unapply(m, _rotateTransform.default)
                    }
                });
                return new _point.default(m.tx, m.ty)
            }
        }, {
            key: "destroy",
            value: function destroy() {
                delete this._scaleTransform;
                delete this._rotateTransform;
                delete this._translateTransform;
                delete this._transforms
            }
        }, {
            key: "localRotation",
            get: function get() {
                var m = _matrix.default.identity(3);
                this.applyToLocalTransform(m, _rotateTransform.default);
                return m.angle
            }
        }, {
            key: "globalRotation",
            get: function get() {
                var m = _matrix.default.identity(3);
                this.applyToGlobalTransform(m, _rotateTransform.default);
                return m.angle
            }
        }, {
            key: "localScale",
            get: function get() {
                var m = _matrix.default.identity(3);
                this.applyToLocalTransform(m, _scaleTransform.default);
                return new _point.default(m.scaleX, m.scaleY)
            }
        }, {
            key: "globalScale",
            get: function get() {
                var m = _matrix.default.identity(3);
                this.applyToGlobalTransform(m, _scaleTransform.default);
                return new _point.default(m.scaleX, m.scaleY)
            }
        }, {
            key: "globalScaleTest",
            get: function get() {
                var m = _matrix.default.identity(3);
                m.scale(1, 1);
                var allTransformers = [];
                var parent = this.element;
                do {
                    if (parent.transformer) {
                        allTransformers.push({
                            transformer: parent.transformer,
                            renderTransform: parent.renderTransform
                        })
                    }
                } while ((parent = parent.parentElement) !== null);
                allTransformers.reverse().forEach(function(_ref4) {
                    var transformer = _ref4.transformer,
                        renderTransform = _ref4.renderTransform;
                    if (transformer) {
                        transformer._transforms.apply(m, _scaleTransform.default)
                    }
                    if (renderTransform) {
                        renderTransform.apply(m, _scaleTransform.default)
                    }
                });
                var scaleX = m.a;
                var scaleY = m.d;
                return new _point.default(scaleX, scaleY)
            }
        }]);
        return Transformer
    }();
    exports.default = Transformer
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.bind = void 0;
    var _transformer = _interopRequireDefault(__webpack_require__(7));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }
    var bind = function bind(element, callback, debug) {
        if (!("Promise" in window)) {
            throw new Error("transformer.js requires Promise")
        }
        return new Promise(function(resolve, reject) {
            if (element.transformer) {
                return resolve(element.transformer)
            }
            setTimeout(function() {
                var transformer = new _transformer.default(element, callback, debug);
                transformer.reapplyTransforms().then(function() {
                    resolve(transformer)
                })
            }, 0)
        })
    };
    exports.bind = bind
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    Object.defineProperty(exports, "Point", {
        enumerable: true,
        get: function get() {
            return _point.default
        }
    });
    Object.defineProperty(exports, "Matrix", {
        enumerable: true,
        get: function get() {
            return _matrix.default
        }
    });
    Object.defineProperty(exports, "TranslateTransform", {
        enumerable: true,
        get: function get() {
            return _translateTransform.default
        }
    });
    Object.defineProperty(exports, "RotateTransform", {
        enumerable: true,
        get: function get() {
            return _rotateTransform.default
        }
    });
    Object.defineProperty(exports, "ScaleTransform", {
        enumerable: true,
        get: function get() {
            return _scaleTransform.default
        }
    });
    Object.defineProperty(exports, "TransformGroup", {
        enumerable: true,
        get: function get() {
            return _transformGroup.default
        }
    });
    Object.defineProperty(exports, "bind", {
        enumerable: true,
        get: function get() {
            return _bind.bind
        }
    });
    Object.defineProperty(exports, "hammerize", {
        enumerable: true,
        get: function get() {
            return _hammerize.hammerize
        }
    });
    var _point = _interopRequireDefault(__webpack_require__(1));
    var _matrix = _interopRequireDefault(__webpack_require__(0));
    var _translateTransform = _interopRequireDefault(__webpack_require__(3));
    var _rotateTransform = _interopRequireDefault(__webpack_require__(4));
    var _scaleTransform = _interopRequireDefault(__webpack_require__(5));
    var _transformGroup = _interopRequireDefault(__webpack_require__(6));
    var _transformer = _interopRequireDefault(__webpack_require__(7));
    var _bind = __webpack_require__(8);
    var _hammerize = __webpack_require__(10);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.hammerize = void 0;
    var _point = _interopRequireDefault(__webpack_require__(1));
    var _translateTransform = _interopRequireDefault(__webpack_require__(3));
    var _rotateTransform = _interopRequireDefault(__webpack_require__(4));
    var _scaleTransform = _interopRequireDefault(__webpack_require__(5));
    var _transformGroup = _interopRequireDefault(__webpack_require__(6));
    var _bind = __webpack_require__(8);
    var _hammerjs = _interopRequireDefault(__webpack_require__(11));

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        }
    }
    var hammerize = function hammerize(obj, options) {
        return new Promise(function(resolve, reject) {
            var Hammer = window.Hammer;
            options = Object.assign({
                pan: true,
                rotate: true,
                pinch: true,
                callback: undefined,
                enabled: true,
                debug: false
            }, options);
            (0, _bind.bind)(obj, options.callback, options.debug).then(function(transformer) {
                var hammerManager = new Hammer.Manager(obj);
                obj.hammer = hammerManager;
                var _destroy = transformer.destroy;
                transformer.destroy = function() {
                    hammerManager.destroy();
                    _destroy.call(this)
                };
                hammerManager.add(new Hammer.Pan({
                    threshold: 0,
                    pointers: 0
                }));
                hammerManager.add(new Hammer.Rotate({
                    threshold: 0
                })).recognizeWith(hammerManager.get("pan"));
                hammerManager.add(new Hammer.Pinch({
                    threshold: 0
                })).recognizeWith([hammerManager.get("pan"), hammerManager.get("rotate")]);
                var renderTransform = new _transformGroup.default;
                var scaleTransform = obj.scaleTransform = new _scaleTransform.default;
                var rotateTransform = obj.rotateTransform = new _rotateTransform.default;
                var translateTransform = obj.translateTransform = new _translateTransform.default;
                renderTransform.add(scaleTransform);
                renderTransform.add(rotateTransform);
                renderTransform.add(translateTransform);
                obj.renderTransform = renderTransform;
                var isEnabled = function isEnabled() {
                    if (typeof options.enabled === "function") {
                        return options.enabled.call(transformer)
                    }
                    return options.enabled
                };
                var isValidEvent = function isValidEvent(event) {
                    var parent = event.target;
                    do {
                        if (parent.transformer) {
                            return parent === obj
                        }
                    } while ((parent = parent.parentElement) !== null);
                    return false
                };
                var consumeEvent = function consumeEvent(event) {
                    event.srcEvent.stopPropagation()
                };
                var adjustCenterPoint = function adjustCenterPoint(point) {
                    var p = new _point.default(point.x, point.y);
                    return obj.transformer.fromGlobalToLocal(p)
                };
                var prevPoint = {
                    x: 0,
                    y: 0
                };
                var prevScale = 1;
                var angleOffset = 0;
                var prevAngle = 0;
                hammerManager.on("hammer.input", function(event) {
                    if (!isEnabled()) return;
                    if (!isValidEvent(event)) return;
                    consumeEvent(event);
                    if (event.isFinal) {
                        transformer.complete()
                    }
                });
                hammerManager.on("panstart panmove", function(event) {
                    if (!isEnabled()) return;
                    if (!options.pan) return;
                    if (event.type === "panstart") {
                        prevPoint.x = 0;
                        prevPoint.y = 0;
                        return
                    }
                    var deltaPoint = new _point.default(event.deltaX, event.deltaY);
                    deltaPoint = transformer.fromGlobalToLocalDelta(deltaPoint);
                    var newX = translateTransform.x - prevPoint.x + deltaPoint.x;
                    var newY = translateTransform.y - prevPoint.y + deltaPoint.y;
                    translateTransform.set(newX, newY);
                    transformer.reapplyTransforms();
                    prevPoint.x = deltaPoint.x;
                    prevPoint.y = deltaPoint.y
                });
                hammerManager.on("rotatestart rotatemove", function(event) {
                    if (!isEnabled()) return;
                    if (!options.rotate) return;
                    if (event.type === "rotatestart") {
                        angleOffset = event.rotation;
                        prevAngle = 0;
                        var centerPoint = adjustCenterPoint(event.center);
                        rotateTransform.centerPoint.x = centerPoint.x;
                        rotateTransform.centerPoint.y = centerPoint.y;
                        return
                    }
                    event.rotation -= angleOffset;
                    var deltaAngle = rotateTransform.angle - prevAngle + event.rotation;
                    prevAngle = event.rotation;
                    rotateTransform.set(deltaAngle);
                    transformer.reapplyTransforms()
                });
                hammerManager.on("pinchstart pinchmove", function(event) {
                    if (!isEnabled()) return;
                    if (!options.pinch) return;
                    if (event.type === "pinchstart") {
                        prevScale = event.scale;
                        var centerPoint = adjustCenterPoint(event.center);
                        scaleTransform.centerPoint.x = centerPoint.x;
                        scaleTransform.centerPoint.y = centerPoint.y;
                        return
                    }
                    var scaleX = scaleTransform.x / prevScale * event.scale;
                    var scaleY = scaleTransform.y / prevScale * event.scale;
                    prevScale = event.scale;
                    scaleTransform.set(scaleX, scaleY);
                    transformer.reapplyTransforms()
                });
                var mouseWheelManipulated = false;
                obj.addEventListener("mousemove", function() {
                    if (mouseWheelManipulated) {
                        transformer.complete();
                        mouseWheelManipulated = false
                    }
                });
                obj.addEventListener("mousewheel", function(event) {
                    if (!isEnabled()) return;
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    mouseWheelManipulated = true;
                    var wheel = event.wheelDelta / 120;
                    var manipulationFactor = Math.exp(wheel * .02);
                    var centerPoint = {
                        x: event.clientX,
                        y: event.clientY
                    };
                    centerPoint = adjustCenterPoint(centerPoint);
                    if (event.ctrlKey) {
                        if (!options.rotate) return;
                        var deltaAngle = -(manipulationFactor - 1) * 50;
                        var angle = (rotateTransform.angle - deltaAngle) % 360;
                        rotateTransform.set(angle);
                        rotateTransform.centerPoint.x = centerPoint.x;
                        rotateTransform.centerPoint.y = centerPoint.y;
                        transformer.reapplyTransforms();
                        return
                    }
                    if (!options.pinch) return;
                    var newScale = scaleTransform.x * manipulationFactor;
                    scaleTransform.set(newScale, newScale);
                    scaleTransform.centerPoint.x = centerPoint.x;
                    scaleTransform.centerPoint.y = centerPoint.y;
                    transformer.reapplyTransforms()
                }, false);
                resolve(transformer)
            })
        })
    };
    exports.hammerize = hammerize
}, function(module, exports) {
    (function() {
        module.exports = window["hammerjs"]
    })()
}]);